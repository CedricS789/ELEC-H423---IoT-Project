\chapter{Security Mitigation}

\section{Security scheme}

The security scheme is designed to protect the IoT communication channel against all attack types explained in the STRIDE section. 
An application-layer security protocol has been implemented to ensure authentification, data privacy and integrity before it even reaches the network stack.
The security protocol from the publisher to the broker can be seen on the figure ~\ref{fig:Security_pipeline} - the security from the broker to the receiver
being symmetrical.  Each steps of the security strategy will be explained below and the additional security features will be highlited.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{../pic/Security_pipeline.PNG}
    \caption{Security strategy integration in the project data flow}
    \label{fig:Security_pipeline}
\end{figure}

\subsubsection{Key Generation and Management - PBKDF2 with Morse code \textbf{Feature 1}}
To avoid storing the master encryption key in plaintext within the flash memory, 
our group conceptualize a password-based key derivation function. At startup, the user manually inputs a secret password using a push-button interpreted as Morse code. 
This password is then passed through the PBKDF2 algorithm using HMAC-SHA256 to derive a session key, namely the $\text{Key}_\text{user}$. 
The actual encryption key, which is stored in the non-volatile storage (assumed to be secured and considered as trusted area), is then decrypted using this session key. 
The decrypted key - $\text{Key}_\text{plain}$ is stored only in RAM and used for the duration of the session - the RAM memory considered \textit{underwatch} and therefore physically unattackable.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{../pic/Encrypted_key.PNG}
    \caption{Encrypted key generation}
    \label{fig:Encrypted_key}
\end{figure}


\subsubsection{Encryption and Confidentiality}
The sensor data, including temperature and humidity, is formatted into a JSON structure. 
This payload is then encrypted using AES-128 in Cipher Block Chaining mode. For each message, 
a fresh Initialization Vector is randomly generated to ensure that the same data results in different ciphertexts every time. 
The payload is then encrypted using the \text{plain} key - $\text{Key}_\text{plain}$ - decrypted during the startup phase.

\subsubsection{Authentication verification and Integrity}
To ensure the authenticity and integrity of the message, an HMAC-SHA256 signature is generated. 
The final message payload includes the IV, a sequence counter, and the encrypted data. 
An HMAC-SHA256 signature is calculated over this entire message using the session key. 
The message and its corresponding signature are published to separate MQTT topics.\\
For our project scope, the data flow has been windowed from the first ESP32 (publisher) to the second one (subscriber) for data monitoring.  In practice, the subscriber would
send back control signals to the first ESP32 in order to adjust the thermal conditions of the room.  Thus the data flow is bidirectional.
In this perspective, we assume that :
\begin{itemize}
        \item Each ESP32 has dedicated key (symmetrical) for encryption depending on which device sends packets (ensuring proper authentification).
        Thus, there would be two pairs of symmetric keys - One pair when the acquisition device sends data - the second pair when the control device sends data back. 
        \item Key are saved at the brocker in protected memory on the host machine and in the secured flash of our ESP32s.
        \item At each entity, the packet authenticity can be confirmed by the HMAC verification.
    \end{itemize}

\subsubsection{Repudiation Protection}
A monotonic counter is maintained by the publisher and stored in non-volatile memory to survive reboots. 
The counter is incremented for every sent message and embedded in the payload. 
Since the counter is part of the data covered by the HMAC, it cannot be tampered with. 
The subscriber tracks the last received counter value.
Any received message with a counter lower than or equal to the last valid counter is rejected to ensure non-repudiation.
Depending on the \textit{quality of service} level selected on the brocker, a packet may be lost \textbf{at application layer} without any counter-actions, redelivered multiple times with
an acknowledgement system in one direction or ensured to be treated with a bidirectional handshakes. Our strategy ensures that :
\begin{itemize}
        \item whatever the selected \textbf{QoS} level, the client - brocker / client-client communication will not be stalled due to a 
        packet loss.
        \item all the past packets not delivered in time (before the next packet), containing outdated information about the room 
        condition, will be discarded.
    \end{itemize}
Therefore, the counter protocol contibutes on the authentication security layer (when combined with the HMAC) but also prevents replay attacks, ensuring that lost or delayed packets cannot be reused maliciously or 
providing a misinterpretation of the current thermal situation.
It is important to point out that assumption is made here that counters are stored, with the clients keys and the published messages, in a OS-level log file on the brocker side too.
\subsubsection{Network Defense via Port Knocking - \textbf{Feature 2}}
As an additional layer of obfuscation, the system implements a synchronized port rotation mechanism. 
Both the publisher and subscriber cycle through a predefined sequence of MQTT broker ports. After a successful transmission, 
both devices switch to the next port in the sequence, making continuous passive sniffing more difficult for an attacker listening on a single port.

\subsubsection{Rate limitation and Quiet mode functionnality - \textbf{Feature 3}}

The final security layer, designed to mitigate flooding attacks, relies on rate limiting at the publisher and a quiet mode
mechanism at the subscriber.
At the publisher side, the setup restricts the sending of packets to one every 20 seconds. At the subscriber side,
if 10 consecutive attack attempts are detected, the device temporarily unsubscribes from the broker topics and waits
20 seconds before resubscribing. This approach helps prevent excessive load on the network and ensures system 
resilience against repeated request floods.\\
Additionnally, the \textbf{port knocking} layer provides further protection against denials of services.

\section{Results}

In thi section, we will review the results obtained during the implementation of the thermal regulation concept - previously discussed - with
 two ESP32 communicating through a MQTT server in a fully securised environment (authentification, confidentiality and integrity).

We will proceed step by step by confirming the implementation of :

\begin{enumerate}
    \item The morse code acquisition with debouncing function for security
    \item PBKDF2 key generation and decryption of the encrypted key in the flash memory
    \item Encryption of the payload with the decrypted key
    \item Decryption of the payload at the subscriber
    \item Replay detection verification
    \item Port knocking verification
\end{enumerate}

\subsection{Morse Code}
The morse code acquisition passes by the implementation of a look-up table translated unique succession of \textbf{dots} and \textbf{dashes} 
to an alphabetic letter. These \textbf{dots} and \textbf{dashes} being generated depending on the duration when the push button has been pressed.
Just to ensure the translation code was correctly implemented, the code compares the morse code encoded and the one we should use to decrypt the
key stored in the flash. Of course, this verification is not done in practice as it would mean the morse code is stored in the flash memory which
could be an additional break in our security strategy - morse code is supposed to be kept secret and shared verbally.

Figure ~\ref{fig:Morse_Code_check} shows the results of the last letter encoding (and the  the verification of the morse code).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{../pic/Morse_Code_check.PNG}
    \caption{Morse code implementation Result}
    \label{fig:Morse_Code_check}
\end{figure}


\subsection{PBKDF2 encryption}

The following security phase is the decryption of the encrypted key saved in the non-volatile memory through the PBKDF2 encryption and AES decryption.
The figure ~\ref{fig:PBKDF2_result} shows the following results :

\begin{enumerate}
    \item Morse code encoded with the push button
    \item Derived 16-bytes key generated by the PBKDF2 algorithm (Morse, "Salt", HMAC 256, 1000 iterations)
    \item Encrypted 32-bytes key saved in the flash - $\text{Key}_\text{enc}= \text{AES}(\text{IV code}, \text{Key}_\text{plain})$
    \item Decryption of the key - $\text{Key}_\text{plain}= \text{Dec}(\text{IV code}, \text{Key}_\text{enc})$
    \item $\text{Key}_\text{plain} =  0\text{x}54,0\text{x}68,0\text{x}61,0\text{x}74,0\text{x}73,0\text{x}20,0\text{x}6d,0\text{x}79,0\text{x}20,0\text{x}4b,0\text{x}75,0\text{x}6e,0\text{x}67,0\text{x}20,0\text{x}46,0\text{x}75$ - \textbf{Thats my Kung Fu} in 16 ASCII
\end{enumerate}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{../pic/PBKDF2_result.PNG}
    \caption{PBKDRF2 encryption verification}
    \label{fig:PBKDF2_result}
\end{figure}

\subsection{Encrypted data publishment}

Once the plain key ($\text{Key}_\text{plain}$) has been generated, the thermal data can be encrypted with AES-128 bits encryption.
The figure ~\ref{fig:Encrypted_data_publish} shows the details fo the encryption functionality and the results of the encrypted payload.

\begin{enumerate}
    \item Thermal conditions gathered in a java script object notation (readable text to send structured data)
    \item IV and plain key shown for transparency in \textbf{Arduino String}
    \item Hmac and cypher payload generation with AES-128 bits encryption.
    \item Publishment of the data on the MQTT server after client connexion on MQTT server on dedicated port.
\end{enumerate}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{../pic/Encrypted_data_publish_2.PNG}
    \caption{Encrypted data publishment on MQTT server}
    \label{fig:Encrypted_data_publish}
\end{figure}

\subsection{Decryption at the subscriber}

The second ESP32 subscribed to the same MQTT server - listening to the same port as the publisher - receives the cypher message containing
 HMAC signature and encrypted payload.  From the inverse encryption process, the cypher is decrypted and the result details are shown in the 
figure ~\ref{fig:Subscription_MQTT} and ~\ref{fig:Decrypted_data_subscriber}.

\begin{enumerate}
    \item Encrypted message and HMAC signature sent to the subscriber
    \item Payload decrypted with the plain key (decrypted at the subscriber with the same secret morse code)
    \item Display of the counter countering replay attacks.
\end{enumerate}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{../pic/Subscription_MQTT.PNG}
    \caption{Subscription to MQTT server topics}
    \label{fig:Subscription_MQTT}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{../pic/Decrypted_data_subscriber.PNG}
    \caption{Decryption verification}
    \label{fig:Decrypted_data_subscriber}
\end{figure}

\subsection{Port Knocking}

To complete the results section, the terminal shows the results got during data sending experiment from the subscriber side. \\
One can observe that the port is switching once the packet has been received - \textbf{Switching Subscribed port : 1900}.  This port switch
simulates a synchronised port switching between the publisher - MQTT server and the subscriber.

Figure ~\ref{fig:Port_Knocking_visualization}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{../pic/Port_Knocking_visualization.PNG}
    \caption{Port switching for sniffing security improvement}
    \label{fig:Port_Knocking_visualization}
\end{figure}

\section{Discussion}

In this section, we discuss the security assumptions and the remaining limitations of our implementation.

\subsection*{Hardware trust assumptions}
In our design, we "assume" that the MQTT broker runs on a trusted computer and that the ESP32 flash memory is protected at the hardware level. Under this assumption, the attackers can observe and modify the wireless traffic, but they cannot directly read or overwrite the keys stored in flash or the files of the MQTT server.

If this assumption is violated (for instance, if an attacker obtains physical access to the board and can dump the flash contents), our scheme would not be sufficient: the long–term AES key and the PBKDF2 parameters could be extracted, and all traffic could be decrypted
offline.

\subsection*{Port knocking and synchronisation}

As an additional defence in depth, we implemented a form of \emph{port knocking} on the ESP32 side. Instead of always sending encrypted MQTT traffic to a single fixed port, the publisher and subscriber cycle through a predefined list of ports (1883 $\rightarrow$ 1900 $\rightarrow$ 1925 $\rightarrow$ 1960 $\rightarrow \dots$). After each encrypted payload is sent and acknowledged, both ESP32 devices update an internal index and reconnect to the broker using the next port in the sequence. This makes passive sniffing slightly more difficult, because an attacker cannot simply capture all traffic by listening on a single port. 

In a \emph{strict} port‑knocking design, the MQTT broker would enforce the same sequence: the server would initially keep all application ports closed and only open the next port in 
the list after a correct "knock" on the current one. Such behaviour requires the synchronisation between the client and the server. If the broker does not follow the same sequence, an attacker who listens on all open ports can still observe every packet.
A time-based synchronisation with ports sequence shared in amont through the first encrypted packets would enhance the port knocking security.  It is worth mentionning that such security implementation may become complex for scalability (clock synchronisation - port list sharing - dedicated port connection for new client connection).

In our implementation the Mosquitto broker is configured to listen on all ports of the sequence at the same time, without enforcing any ordering as it would requires a modification of the server code source. As a consequence, our port‑switching mechanism ,implemented as it is, is a naive/theoretical protection against sniffing. A possible improvement for future work would be to move the port‑knocking logic to the server side with a clock-based port sequence switch so that only the correct sequence of ports, \textbf{at the right timing}, is accepted and all other connection attempts are rejected.

\subsection*{Side–channel leakage}

The implemented counter‑measures mainly address network‑level threats such as spoofing, tampering and replay. On a small micro‑controller there are additional side‑channel attacks: an attacker could measure execution time, count low‑level instructions or observe power consumption in order to recover information about the AES key.

Protecting against these attacks is outside the scope of this work but one should be aware that a multi-layered protection such as implemented in this projet would not able to prevent this kind of low-hardware level attacks. In practice, defending against side channels would require constant‑time cryptographic implementations and specific hardware counter‑measures, which are not provided in our prototype.

\subsection*{Security level of AES‑128}

The payload is encrypted with AES in CBC mode with a 128‑bit key. From a purely cryptographic point of view, AES‑128 is still considered secure for most applications and no practical attack is known that breaks the algorithm with a realistic amount of resources.

However, for highly sensitive data and long‑term confidentiality, standards often recommend larger keys (e.g. AES‑256) and additional protections such as key rotation.  In our project the main limitations are therefore not the theoretical strength of AES‑128 itself but the way keys are stored, derived and handled on low‑cost IoT hardware.


