\chapter{Security Mitigation}

\textbf{Discuss about} 

\begin{enumerate}
    \item Hardware being crypted (assumption)
    \item Key being encrypted with usage of morse code through PBDKF2 ( Additional feature !!) and saved in flash
    \item Decryption of the key with morse code before sending payload to get back the plain key 
    \item Encryption of paylaod with AES-128 bits encryption (low ressources demand)
    \item Data sent to MQTT server (assumed to have a secured hardware and files secured too in the OS)
    \item HMAC generation for ensuring authentification (at MQTT server - assumption) at the surbscriber
    \item Replay detection verification with counter (at MQTT server - assumption) at the surbscriber
    \item Port knocking implementation to complexify the sniffing (changing port)
\end{enumerate}

\section{Security scheme}

The security scheme is designed to protect the IoT communication channel against information disclosure, tampering, and repudiation. 
We implemented a custom application-layer security protocol that ensures data privacy and integrity before it even reaches the network stack.

\subsubsection{Key Generation and Management}
To avoid storing the master encryption key in plaintext within the source code or the flash memory, 
the system uses a password-based key derivation function. At startup, the user manually inputs a secret password using a push-button interpreted as Morse code. 
This password is then passed through the PBKDF2 algorithm using HMAC-SHA256 to derive a session key. 
The actual encryption key, which is stored in the non-volatile storage in an encrypted form, is then decrypted using this session key. 
The decrypted key is stored only in RAM and used for the duration of the session.

\subsubsection{Encryption and Confidentiality}
The sensor data, including temperature and humidity, is formatted into a JSON structure. 
This payload is then encrypted using AES-128 in CBC mode. For each message, 
a fresh Initialization Vector (IV) is randomly generated to ensure that the same data results in different ciphertexts every time. 
The payload is then encrypted using the session key derived during the startup phase.

\subsubsection{Authentication verification and Integrity}
To ensure the authenticity and integrity of the message, an HMAC-SHA256 signature is generated. 
The final message payload includes the IV, a sequence counter, and the encrypted data. 
An HMAC-SHA256 signature is calculated over this entire message using the session key. 
The message and its corresponding signature are published to separate MQTT topics.

\subsubsection{Repudiation Protection}
A monotonic counter is maintained by the publisher and stored in non-volatile memory to survive reboots. 
The counter is incremented for every sent message and embedded in the payload. 
Since the counter is part of the data covered by the HMAC, it cannot be tampered with. 
The subscriber tracks the last received counter value. 
Any received message with a counter lower than or equal to the last valid counter is rejected to ensure non-repudiation.

\subsubsection{Network Defense via Port Knocking}
As an additional layer of obfuscation, the system implements a synchronized port rotation mechanism. 
Both the publisher and subscriber cycle through a predefined sequence of MQTT broker ports. After a successful transmission, 
both devices switch to the next port in the sequence, making continuous passive sniffing more difficult for an attacker listening on a single port.

Figure ~\ref{fig:Encrypted_key}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{../pic/Encrypted_key.PNG}
    \caption{Encrypted key generation}
    \label{fig:Encrypted_key}
\end{figure}

Figure ~\ref{fig:Security_pipeline}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{../pic/Security_pipeline.PNG}
    \caption{Security strategy integration in the project data flow}
    \label{fig:Security_pipeline}
\end{figure}

\section{Results}

In thi section, we will review the results obtained during the implementation of the thermal regulation concept - previously discussed - with
 two ESP32 communicating through a MQTT server in a fully securised environment (authentification, confidentiality and integrity).

We will proceed step by step by confirming the implementation of :

\begin{enumerate}
    \item The morse code acquisition with debouncing function for security
    \item PBKDF2 key generation and decryption of the encrypted key in the flash memory
    \item Encryption of the payload with the decrypted key
    \item Decryption of the payload at the subscriber
    \item Replay detection verification
    \item Port knocking verification
\end{enumerate}

\subsection{Morse Code}
The morse code acquisition passes by the implementation of a look-up table translated unique succession of \textbf{dots} and \textbf{dashes} 
to an alphabetic letter. These \textbf{dots} and \textbf{dashes} being generated depending on the duration when the push button has been pressed.
Just to ensure the translation code was correctly implemented, the code compares the morse code encoded and the one we should use to decrypt the
key stored in the flash. Of course, this verification is not done in practice as it would mean the morse code is stored in the flash memory which
could be an additional break in our security strategy - morse code is supposed to be kept secret and shared verbally.

Figure ~\ref{fig:Morse_Code_check} shows the results of the last letter encoding (and the  the verification of the morse code).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{../pic/Morse_Code_check.PNG}
    \caption{Morse code implementation Result}
    \label{fig:Morse_Code_check}
\end{figure}


\subsection{PBKDF2 encryption}

The following security phase is the decryption of the encrypted key saved in the non-volatile memory through the PBKDF2 encryption and AES decryption.
The figure ~\ref{fig:PBKDF2_result} shows the following results :

\begin{enumerate}
    \item Morse code encoded with the push button
    \item Derived 16-bytes key generated by the PBKDF2 algorithm (Morse, "Salt", HMAC 256, 1000 iterations)
    \item Encrypted 32-bytes key saved in the flash - $\text{Key}_\text{enc}= \text{AES}(\text{IV code}, \text{Key}_\text{plain})$
    \item Decryption of the key - $\text{Key}_\text{plain}= \text{Dec}(\text{IV code}, \text{Key}_\text{enc})$
    \item $\text{Key}_\text{plain} =  0\text{x}54,0\text{x}68,0\text{x}61,0\text{x}74,0\text{x}73,0\text{x}20,0\text{x}6d,0\text{x}79,0\text{x}20,0\text{x}4b,0\text{x}75,0\text{x}6e,0\text{x}67,0\text{x}20,0\text{x}46,0\text{x}75$ - \textbf{Thats my Kung Fu} in 16 ASCII
\end{enumerate}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{../pic/PBKDF2_result.PNG}
    \caption{PBKDRF2 encryption verification}
    \label{fig:PBKDF2_result}
\end{figure}

\subsection{Encrypted data publishment}

Once the plain key ($\text{Key}_\text{plain}$) has been generated, the thermal data can be encrypted with AES-128 bits encryption.
The figure ~\ref{fig:Encrypted_data_publish} shows the details fo the encryption functionality and the results of the encrypted payload.

\begin{enumerate}
    \item Thermal conditions gathered in a java script object notation (readable text to send structured data)
    \item IV and plain key shown for transparency in \textbf{Arduino String}
    \item Hmac and cypher payload generation with AES-128 bits encryption.
    \item Publishment of the data on the MQTT server after client connexion on MQTT server on dedicated port.
\end{enumerate}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{../pic/Encrypted_data_publish_2.PNG}
    \caption{Encrypted data publishment on MQTT server}
    \label{fig:Encrypted_data_publish}
\end{figure}

\subsection{Decryption at the subscriber}

The second ESP32 subscribed to the same MQTT server - listening to the same port as the publisher - receives the cypher message containing
 HMAC signature and encrypted payload.  From the inverse encryption process, the cypher is decrypted and the result details are shown in the 
figure ~\ref{fig:Subscription_MQTT} and ~\ref{fig:Decrypted_data_subscriber}.

\begin{enumerate}
    \item Encrypted message and HMAC signature sent to the subscriber
    \item Payload decrypted with the plain key (decrypted at the subscriber with the same secret morse code)
    \item Display of the counter countering replay attacks.
\end{enumerate}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{../pic/Subscription_MQTT.PNG}
    \caption{Subscription to MQTT server topics}
    \label{fig:Subscription_MQTT}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{../pic/Decrypted_data_subscriber.PNG}
    \caption{Decryption verification}
    \label{fig:Decrypted_data_subscriber}
\end{figure}

\subsection{Port Knocking}

To complete the results section, the terminal shows the results got during data sending experiment from the subscriber side. \\
One can observe that the port is switching once the packet has been received - \textbf{Switching Subscribed port : 1900}.  This port switch
simulates a synchronised port switching between the publisher - MQTT server and the subscriber.

Figure ~\ref{fig:Port_Knocking_visualization}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{../pic/Port_Knocking_visualization.PNG}
    \caption{Port switching for sniffing security improvement}
    \label{fig:Port_Knocking_visualization}
\end{figure}

\section{Discussion}

\textbf{Discuss about : }

\begin{enumerate}
    \item the assumption the MQTT server and the ESP32 flashs were secured - hardware level - trust zone area !
    \item That the port knocking can work only if the server switches from one listening port to another listening port in synchronization with the ESP32
    \item Explain that attacks like low-level instructions counting can be used to understand the encryption we used (last year course with Tobias)?
    \item Explain the maybe AES 128-bits encryption is a bit light for sensitive data ? I do not know but maybe be good to check
\end{enumerate}


In this section, we discuss the security assumptions and the remaining limitations of our implementation.

\subsection*{Hardware trust assumptions}
In our design, we "assume" that the MQTT broker runs on a trusted computer and that the ESP32 flash memory is protected at the hardware level. Under this assumption, the attackers can observe and modify the wireless traffic, but they cannot directly read or overwrite the keys stored in flash or the files of the MQTT server.

If this assumption is violated (for instance, if an attacker obtains physical access to the board and can dump the flash contents), our scheme would not be sufficient: the long–term AES key and the PBKDF2 parameters could be extracted, and all traffic could be decrypted
offline.

\subsection*{Port knocking and synchronisation}

As an additional defence in depth, we implemented a form of \emph{port knocking} on the ESP32 side. Instead of always sending encrypted MQTT traffic to a single fixed port, the publisher and subscriber cycle through a predefined list of ports (1883 $\rightarrow$ 1900 $\rightarrow$ 1925 $\rightarrow$ 1960 $\rightarrow \dots$). After each encrypted payload is sent and acknowledged, both ESP32 devices update an internal index and reconnect to the broker using the next port in the sequence. This makes passive sniffing slightly more difficult, because an attacker cannot simply capture all traffic by listening on a single port. 

In a \emph{strict} port‑knocking design, the MQTT broker would enforce the same sequence: the server would initially keep all application ports closed and only open the next port in 
the list after a correct "knock" on the current one. Such behaviour requires the synchronisation between the client and the server. If the broker does not follow the same sequence, an attacker who listens on all open ports can still observe every packet.

In our implementation the Mosquitto broker is configured to listen on all ports of the sequence at the same time, without enforcing any ordering. As a consequence, our port‑switching mechanism should prevent from a naive sniffing. A possible improvement for future work would be to move the port‑knocking logic to the server side so that only the correct sequence of ports is accepted and all other connection attempts are rejected.7

\subsection*{Side–channel leakage}

The implemented counter‑measures mainly address network‑level threats such as spoofing, tampering and replay. On a small micro‑controller there are additional side‑channel attacks: an attacker could measure execution time, count low‑level instructions or observe power consumption in order to recover information about the AES key.

Protecting against these attacks is outside the scope of this work. In practice, defending against side channels would require constant‑time cryptographic implementations and specific hardware counter‑measures, which are not provided in our prototype.

\subsection*{Security level of AES‑128}

The payload is encrypted with AES in CBC mode with a 128‑bit key. From a purely cryptographic point of view, AES‑128 is still considered secure for most applications and no practical attack is known that breaks the algorithm with a realistic amount of resources.

However, for highly sensitive data and long‑term confidentiality, standards often recommend larger keys (e.g. AES‑256) and additional protections such as key rotation.  In our project the main limitations are therefore not the theoretical strength of AES‑128 itself but the way keys are stored, derived and handled on low‑cost IoT hardware.


\section{Conclusion}


